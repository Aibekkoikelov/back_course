const jwt = require("jsonwebtoken");  // скачиваем библиотеку  npm i jsonwebtoken --save и  импортируем ее
// const db = require("../models"); // импортируем модель базы данных для работы с ней
class TokenService { // созаем класс в котром описываем все методы для работы с токенами. Будем использовать его при регистрации и авторизации пользователя
    // в методе generateToken мы создаем два токена, один для доступа к ресурсам, другой для обновления токена доступа
    generateToken(payload) {  // payload - это данные которые мы хотим поместить в токен
        // accessToken - это токен который будет действовать 15 минут. С помощью него пользователь будет получать доступ к ресурсам
        const accessToken = jwt.sign(//  используем метод sign для создания токена
            payload,  // первый параметр это данные которые мы хотим поместить в токен
            process.env.JWT_ACCESS_SECRET, { // второй параметр это секретный ключ, который будет использоваться для создания токена ( чтобы расшифровать токен нужно знать этот ключ)
            expiresIn: "15m", // время жизни токена
        },
            { algorithm: "HS256" }); // алгоритм шифрования (Чтобы не было проблем с кодировкой, мы будем использовать алгоритм HS256)
        // refreshToken - это токен который будет действовать 30 дней. С помощью него пользователь будет обновлять токен доступа
        const refreshToken = jwt.sign(  //  используем метод sign для создания токена
            payload, // первый параметр это данные которые мы хотим поместить в токен
            process.env.JWT_REFRESH_SECRET, { // второй параметр это секретный ключ, который будет использоваться для создания токена
            expiresIn: "7d", // время жизни токена ( ставим сколько угодно, но не больше 30 дней) рекомендация - 7 дней
        }, { algorithm: "HS256" }); // алгоритм шифрования
        return { accessToken, refreshToken }; // возвращаем объект с двумя токенами
    }
    // метод для проверки токена доступа
    validateAccessToken(token) { // в качестве параметра передаем токен
        try{ // при помощи try catch обрабатываем ошибки ( если токен не валидный, то будет ошибка)
            return jwt.verify( // метод verify проверяет токен
                token,  // первый параметр это токен
                process.env.JWT_ACCESS_SECRET,  // второй параметр это секретный ключ, который будет использоваться для создания токена
                {algorithm: "HS256"},  // алгоритм шифрования
                (err, decoded) => { // второй параметр это колбэк функция, которая будет вызвана после проверки токена
                if (err) { // если есть ошибка, то возвращаем false
                    return null; // возвращаем null
                }
                return decoded; // если ошибки нет, то возвращаем расшифрованный токен
            });
        }catch(err) { // если есть ошибка, то возвращаем false
            return null // возвращаем null
        }
    }
    // метод для проверки токена обновления
    // такая же логика как и с токеном доступа
    validateRefreshToken(token) { // в качестве параметра передаем токен
        try{
            return jwt.verify(
                token,
                process.env.JWT_REFRESH_SECRET, // берем секретный ключ для токена обновления в .env файле ( не забываем добавить в .gitignore)
                {algorithm: "HS256"},
                (err, decoded) => {
                if (err) {
                    return null;
                }
                return decoded;
            });
        }catch(err) {
            return null
        }
    }
    // рефреш токен надо также сохранить в базе данных, чтобы при следующем запросе на рефреш токен, мы могли проверить его наличие в базе данных
    async  saveToken(userId, refreshToken) { // метод принимает id пользователя и refreshToken
        const tokenData = await db.Token.findOne({where: {userId}}); // ищем токен в базе данных по id пользователя
        if(tokenData){ // если токен есть, то обновляем его
            tokenData.refreshToken = refreshToken; // обновляем refreshToken
            tokenData.save() // сохраняем в базе данных
        }
        return await db.Token.create({userId, refreshToken}); // если токена нет, то создаем новый
    }
    // метод для удаления токена из базы данных
    async deleteRefreshToken(refreshToken) { // метод принимает refreshToken
        return await db.Token.destroy({where: {refreshToken}}); // удаляем токен из базы данных
    }
    // метод для проверки токена в базе данных
    async findToken (refreshToken) { // метод принимает refreshToken
        return await db.Token.findOne({where: {refreshToken}}); // ищем токен в базе данных
    }


}

module.exports = new TokenService(); // экспортируем класс

// виды алгоритмов шифрования
// HS256 - алгоритм хеширования с симметричным ключом
// RS256 - алгоритм хеширования с ассиметричным ключом
