

// Флаг --save или -S устанавливает зависимость в разделе dependencies в package.json.
// Флаг --save-dev или -D устанавливает зависимость в разделе devDependencies в package.json.

// пакеты используемые в проекте

// npm i express --save  // express - это библотека для создания веб-приложений на Node.js
// npm i jsonwebtoken --save   // jsonwebtoken - это библиотека для создания токенов
// npm i bcrypt --save  // bcrypt - это библиотека для шифрования паролей
// npm i nodemon --save-dev // nodemon - это библиотека для автоматического перезапуска сервера при изменении кода
// npm i swagger-ui-express --save // swagger-ui-express - это библиотека для создания документации API
// npm i express-validator --save // express-validator - это библиотека для валидации данных









// DTO - это объект, который содержит данные, которые будут переданы в другой объект.

// образец DTO
// class UserDto {
//     id;
//     email;
//     isActivated;
//     constructor(model) {
//         this.id = model.id;
//         this.email = model.email;
//         this.isActivated = model.isActivated;
//     }
// }

// DTO в основном используется для того, чтобы скрыть ненужные данные, которые не должны быть переданы в другой объект.
// Например, если вы хотите передать данные пользователя в другой объект, вы можете создать DTO для пользователя,
// который будет содержать только id и email. и в другом объекте вы можете использовать только id и email пользователя, а не все данные пользователя.




// БАЗА ДАННЫХ
// подключение к базе на NestJS
// app.module.ts
// import { Module } from '@nestjs/common';
// import { TypeOrmModule } from '@nestjs/typeorm';
// import { User } from './users/users.model';
// import { UsersModule } from './users/users.module';

// @Module({
//   imports: [
//     TypeOrmModule.forRoot({
//       type: 'postgres',
//       host: 'localhost',
//       port: 5432,
//       username
//       password
//       database
//       autoLoadEntities: true,
//      entities: [User],
//        migrations: ['migration/*.js'],
//       synchronize: true,
//     }),
//     UsersModule,
//   ],
// })
// export class AppModule {}


// DOCKER
// как создать контейнер
//1. создать Dockerfile  - файл, который содержит инструкции для создания образа
  // FROM node:14  // указываем, что будем использовать образ node:14
    // WORKDIR /app // указываем рабочую директорию
    // COPY package*.json ./ // копируем файл package.json в рабочую директорию
    // RUN npm install // устанавливаем зависимости
    // COPY . . // копируем все файлы из текущей директории в рабочую директорию
    // EXPOSE 3000 // открываем порт 3000
    // CMD ["npm", "run", "start:dev"] // запускаем сервер


//2. создать docker-compose.yml  // docker-compose.yml - это файл, в котором описываются все контейнеры, которые будут запущены
    // version: '3.7' // указываем версию
    // services: // указываем, что будут запущены сервисы
    //   db: // название сервиса
    //     image: postgres:12 // указываем, что будем использовать образ postgres:12
    //     container_name: postgres  // название контейнера
    //     restart: always // указываем, что контейнер будет перезапускаться всегда
    //     environment: // указываем переменные окружения
    //       POSTGRES_USER: postgres // логин
    //       POSTGRES_PASSWORD: postgres // пароль
    //       POSTGRES_DB: nest // название базы данных
    //     ports: // указываем порты
    //       - '5432:5432' // порт 5432 на хосте будет проброшен на порт 5432 в контейнере
    //     volumes: // указываем, что будем использовать тома
    //       - ./data:/var/lib/postgresql/data // указываем, что будем использовать том, который будет находиться в папке data в текущей директории и будет примонтирован в папку /var/lib/postgresql/data в контейнере
    //   app: // название сервиса
    //     build: . // указываем, что будем использовать Dockerfile из текущей директории
    //     container_name: nest // название контейнера
    //     restart: always // указываем, что контейнер будет перезапускаться всегда
    //     ports: // указываем порты
    //       - '3000:3000' // порт 3000 на хосте будет проброшен на порт 3000 в контейнере
    //     depends_on: // указываем, что контейнер app будет зависеть от контейнера db
    //       - db // название контейнера db
    //     volumes: // указываем, что будем использовать тома
    //       - .:/app // указываем, что будем использовать том, который будет находиться в текущей директории и будет примонтирован в папку /app в контейнере
    //       - /app/node_modules // указываем, что будем использовать том, который будет находиться в папке node_modules в папке /app в контейнере
    //     environment: // указываем переменные окружения
    //       - NODE_ENV=development // указываем, что будем использовать окружение разработки
    //       - DB_HOST=db // указываем, что хост базы данных будет называться db
    //       - DB_PORT=5432 // указываем, что порт базы данных будет 5432
    //       - DB_USERNAME=postgres // указываем, что логин базы данных будет postgres
    //       - DB_PASSWORD=postgres // указываем, что пароль базы данных будет postgres
    //       - DB_DATABASE=nest // указываем, что название базы данных будет nest

//3. создать .env файл в корне проекта и добавить в него следующие переменные окружения:
    // DB_HOST=db // указываем, что хост базы данных будет называться db
    // DB_PORT=5432 // указываем, что порт базы данных будет 5432
    // DB_USERNAME=postgres // указываем, что логин базы данных будет postgres
    // DB_PASSWORD=postgres // указываем, что пароль базы данных будет postgres
    // DB_DATABASE=nest // указываем, что название базы данных будет nest
    // NODE_ENV=development // указываем, что будем использовать окружение разработки

//4. создать .dockerignore файл в корне проекта и добавить в него следующие строки:
    // node_modules // указываем, что папку node_modules не нужно копировать в контейнер
    // npm-debug.log // указываем, что файл npm-debug.log не нужно копировать в контейнер
    // .env // указываем, что файл .env не нужно копировать в контейнер


//3. в терминале ввести команду docker-compose up -d --build // запускаем контейнеры в фоновом режиме и собираем их заново

//4. в терминале ввести команду docker-compose down // останавливаем контейнеры
